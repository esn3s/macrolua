#summary macrolua instructions
#labels Featured

<wiki:toc max_depth="2" />

----
= Introduction =

The purpose of this Lua script is to play back and record sequences of button presses in a compact format that is easily readable and editable. Some applications:

    * a functional, parseable markup that doubles as a shorthand transcript notation, good for fighting game combo videos
    * a converter that can change an input sequence from a cryptic format such as [http://code.google.com/p/fbarr/wiki/FBMfileformat FBM] to a human readable one for further editing
    * a converter that can change an input sequence from one emulator to another

!MacroLua is portable to any emulator equipped with the core !EmuLua functions. It can still work in a limited capacity if some of the functions are missing.

----
= How to use macros =

Download and set up one of the supported emulators. Choose the latest available version.

Extract the macro archive contents into the emulator's folder. Open _macro-options.lua_ with a text editor and ensure that the macrofile to be played and the path settings are correct. The default path looks for the macros in a folder called _./macro_.

Run the emulator and open the game. Find _Lua Scripting_ in the menus and open a script window. Browse for _macro.lua_ and run it. If there's a gamekey definition module available for your game, it is identified in the output console. In the case of FBA-rr, the _input display.lua_ script is run alongside the macro script.

== How to play back ==

Get to the desired point in the game and press the start key (semicolon) to start playback. The emulator must be unpaused for this start key to be read. Alternatively, pause and then hold the start key while advancing a frame. The macro specified will be analyzed, and warnings appear in the output console if it is misformatted. The macro will play to completion as the game runs normally or in frame advance.

You may replay the macro repeatedly. You may cut the playback short by pressing the start key again before playback is complete. You may also edit the macro file and play the new macro without reloading the script.

== How to record ==

Get to the desired point in the game and press the record key (quote) to start recording. Any keys input by the player(s), by keypress recordings such as FBM, or even by a playing macro will be recorded. Pressing the record key again stops and writes the recording to a _.mis_ file named after the date and time. If multiple players were recorded, the macro is output in asynchronous (bracket) format.

== Key bindings ==

If the emulator supports `input.registerhotkey()`, the keys to start and stop macros are Lua hotkeys 1 and 2 rather than semicolon and quote. These keys can be bound in the emulator's hotkey configuration. In this case, macros can be started and stopped while the game is paused, and it is not necessary to hold the hotkeys while frame advancing.

== Savestates ==

If the emulator supports `savestate.registersave()` and `savestate.registerload()`, the progress of any macros being played or recorded is saved alongside the savestate. Loading this savestate also restores the progress and the playing/recording status. If those functions are not supported, loading a savestate during a macro will cause a desync.

Savestate operations may be invoked manually or written into the script. They are not recorded in macro recording mode.

----
= How to read and write macros =

You may produce macros by recording them or by writing them out according to the format below.

In the following commands, `n` represents a number and `k` represents a key (direction, button or switch) defined by the game's module.
||*`k`*||Input the gamekey k. The key is pressed for the current frame only and then released.||
||*`_k`*||Hold the gamekey k. The key is pressed for the current frame and any subsequent frames until released.||
||*`^k`*||Release the gamekey k, if held.||
||*`*`*||Release all held keys.||
||*`.`*||Advance one frame.||
||*`Wn`*||Advance (wait) n frames.||
||*`+`*||Select player 1.||
||*`-`*||Select the next player.||
||*`<`*||Open a bracketed section and switch control to player 1.||
||*`/`*||Switch to the next player in a bracketed section.||
||*`>`*||Close a bracketed section.||
||*`$n`*||Save the current state to slot n.<br>This can save checkpoints in a long sequence of commands.||
||*`&n`*||Load savestate slot n. This is useful to put in the first frame.||
||*`()n`*||Repeat the commands enclosed in the parentheses n times. Loops can be nested.||
||*`# text`*||A comment. The rest of the line after the symbol is ignored by the script.<br>Comments that explain what the macro does are recommended.||
||*`!`*||End the macro. Any content after the end is ignored by the script, and can be used as comments.<br>Don't forget to advance at least one frame after the last input and before the end.||

Macros are case insensitive. Commas, whitespaces, tabs and newlines can be used for spacing and legibility, but are ignored by the script. The exception is that some separation is required between multiplier or index numbers (such as after a W) and numerical key presses.

Analog inputs are not (yet) supported.

=== Synchronous multi-player control with + - ===

    * Commands are applied only to the selected player.
    * Player 1 is selected by default.
    * The + and - symbols are used to switch between players.
    * Time advancement applies to all players.
    * Nonselected players can give input with their held keys.
    * To modify the input of multiple players on the same frame, switch between them before advancing frames.

=== Asynchronous multi-player control with < / > ===

    * Commands are applied only to the selected player.
    * Player 1 is selected when the brackets are opened.
    * Control is switched to the next player after each /.
    * Time advancement applies only to the selected player.
    * When the brackets are closed, time is advanced to the point of the player with the most frames, wait frames are added to the others to make up the difference, all player inputs are multiplexed, and control returns to player 1.
    * The + - symbols are ignored inside brackets.

=== Savestates ===

Save and load operations are performed one frame before the game inputs at the same position. For example, a state operation placed between the second and third dots is done after the second frame advance, while the game inputs there are done after the third. This behavior allows operations to be scripted on the zeroth frame of the macro, resulting in a movie that effectively starts from savestate.

Each emulator has its own limit on savestate indexes.

----
= How to add control modules =

The available gamekeys depend on the game and system. More gamekey sets can be added as modules. The traditional format is `U`,`D`,`L`,`R` for up, down, left and right, and numbers counting up from `1` for the buttons. The non-arcade systems have a single keyset for all games, so the format only needs to be defined once. However, there are many undefined arcade profiles.

To add an unsupported game, run it in FBA-rr and go to _Input > Map Game Inputs_ and note the names. Open _macro-modules.lua_ with an editor. Copy and paste one of the existing profiles as a template. Edit the first line to give it a reasonable name, and ensure that the first character is the number of players. Edit the things on the right to match the game inputs, and ensure that the first part of any player-specific key starts with `P#`. Remove any lines for keys that don't exist. You may also edit the characters on the left to suit your preference. These are the characters to be typed in the macros.

If no module is working for your game, errors explaining the failure of each available module are output to the console.

----
= How to mute the background music in FBA =

You may want to record videos with the sound effects but without the music. The reliable method to disable music is with a cheat code: The memory addresses that control music are forced to hold values that prevent it from playing.

Find the code that works for your game in the _./cheats/mutecodes.txt_ file provided. Copy the code into an .ini file that matches the rom's short name, for example: "sfa3.ini". You may augment this file with other codes as well. Then run the rom (restart if already running) and find Enable Cheats in the Misc menu. If the .ini is properly formatted, the option is available. Click the music entry and select the disable option from the dropbox.

Not all games have known mute codes. You can request more at [http://cheat.retrogames.com/ Pugsy's site].

----
= Lua feature availability in each emulator =

||||emulator||[http://code.google.com/p/fbarr/downloads/list FBA-rr]||[http://code.google.com/p/pcsxrr/downloads/list PCSX-rr]||[http://code.google.com/p/gens-rerecording/downloads/list Gens-rr]||[http://code.google.com/p/snes9x-rr/downloads/list snes9x-rr]||[http://code.google.com/p/vba-rerecording/downloads/list VBA-rr]||[http://www.fceux.com/web/download.html FCEUX]||[http://code.google.com/p/pcejin/downloads/list PCEjin]||
||||version tested||`0.0.4.01`||`0.1.3`||`11a`||`1.43 v17 r123`<br>`1.51 v6 r113`^1^||`v22 r203`||`2.1.3`||`r128`||
||1||`emu` alias||`fba`||`pcsx`||`gens`||`snes9x`||`vba`||`FCEU`||×||
||2||`input.registerhotkey()`||×||×||○||×||×||×||○||
||2||`input.get()`||○||○||n/a||○||○||○||n/a||
||3||lua+user input||×||×||○||×||×||○||×||
||4||`savestate.registersave()`<br>`savestate.registerload()`||×||×||○||○||×||○^2^||○||
||5||`emu.registerstart()`||×||×||○||×||×||×||×||
||6||(name function)||×||×||×||×||×||×||×||

Elements 1–2 are the minimum required.

   # Lua identifies what the emulator is by the name of this table.
   # This enables the user to start and stop recording while paused.
          * If `input.registerhotkey()` is unavailable, `input.get()` is the fallback. It has the same function but cannot be done while paused.
   # The emulator may take input from both a Lua script and the user simultaneously.
   # The user may load savestates while playing or recording without losing progress. (i.e., bulletproof recording)
   # The script automatically determines the new game name and control scheme when a new game is loaded.
          * No such function that returns the name of the game currently exists.

[http://code.google.com/p/yabause-rr/ yabause-rr] and [http://code.google.com/p/mednafen-rr/ mednafen-rr] do not support Lua whatsoever.

   * `[1]` snes9x 1.51 only accepts Lua input from within a while true do loop, so !MacroLua won't work.
   * `[2]` Loading savestates via Lua crashes FCEUX.