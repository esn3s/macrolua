#summary This document is also available in the download package.
#labels Featured

<wiki:toc max_depth="2" />

----
= Introduction =

The purpose of this Lua script is to play back and record sequences of button presses in a compact format that is easily readable and editable. Some applications:

    * an alternative to using serialized rerecords for recording input, which can be easier with multiple players
    * a functional, parseable markup that doubles as a shorthand transcript notation, good for fighting game combo videos
    * a converter that can change an input sequence from a cryptic format such as [http://code.google.com/p/fbarr/wiki/FBMfileformat FBM] to a human readable one for further editing
    * a converter that can change an input sequence from one emulator to another

!MacroLua is portable to any emulator equipped with the core !EmuLua functions. It can still work in a limited capacity if some of the functions are missing.

----
= A word on MAME-rr =

The current version of [http://code.google.com/p/mame-rr/downloads/list MAME-rr] (0139-test2) has some oddities with the savestate system and the first few scripted frames get merged together. To avoid problems:

    * Start playing scripts with the emulator in an unpaused state. Starting from pause will be off by one frame.
    * Leave at least a few blank frames at the start.
    * Don't try to load states if using recording mode. Recording is not bulletproof.
    * The .luasav files that accompany savestates are necessary for sync, so leave them together.

----
= How to use macros =

Download and set up one of the supported emulators. Choose the latest available version.

Extract the macro archive contents into the emulator's folder. Open _macro-options.lua_  with a text editor and ensure that the macrofile to be played and the path settings are correct. The default path looks for the macros in a folder called _./macro_.

Run the emulator and open the game. Find _Lua Scripting_ in the menus (Ctrl+L in MAME-rr) and open a script window. Browse for _macro.lua_ and run it. If there's a gamekey definition module available for your game, it is identified in the output console. In the case of arcade emus, the _input-display.lua_ script is run alongside the macro script.

== How to play back ==

Get to the desired point in the game and press the start key (semicolon, or whatever is bound to Lua hotkey 1) to start playback. The macro specified will be analyzed, and warnings appear in the output console if it is misformatted. The scripted sequence will proceed as the game runs normally or in frame advance.

You may replay the macro repeatedly. You may cut the playback short by pressing the start key again before playback is complete. You may also edit the macro file and play the new macro without reloading the script.

== How to record ==

Get to the desired point in the game and press the record key (quote) to start recording. Any keys input by the player(s), by keypress recordings such as FBM, or even by a playing macro will be recorded. Pressing the record key again stops and writes the recording to a _.mis_ file named after the date and time. If multiple players were recorded, the macro is output in asynchronous (bracket) format.

== Key bindings ==

If the emulator supports `input.registerhotkey()`, the keys to start and stop macros are Lua hotkeys 1 and 2 rather than semicolon and quote. These keys can be bound in the emulator's hotkey configuration.

== Savestates ==

If the emulator supports `savestate.registersave()` and `savestate.registerload()`, the progress of any macros being played or recorded is saved alongside the savestate. Loading this savestate also restores the progress and the playing/recording status. If those functions are not supported, loading a savestate during a macro will cause a desync.

Even if those functions aren't available, savestate operations may be invoked manually or written into the script, and scripts should start from a savestate to ensure consistent playback. Savestate operations are not recorded in macro recording mode.

----
= How to read and write macros =

You may produce macros by recording them or by writing them out according to the format below.

In the following commands, `n` represents a number and `k` represents a key (direction, button or switch) defined by the game's module.
||*`k`*||Input the gamekey k. The key is pressed for the current frame only and then released.||
||*`_k`*||Hold the gamekey k. The key is pressed for the current frame and any subsequent frames until released.||
||*`^k`*||Release the gamekey k, if held.||
||*`*`*||Release all held keys.||
||*`F`*||Input `R` for player 1 or odd numbered players, or `L` for player 2 or even numbered players.||
||*`B`*||Input `L` for player 1 or odd numbered players, or `R` for player 2 or even numbered players.||
||||`F` and `B` only get substituted if the module is using `L` and `R` and not already using `F` or `B`.||
||*`.`*||Advance one frame.||
||*`Wn`*||Advance (wait) n frames.||
||*`+`*||Select player 1.||
||*`-`*||Select the next player.||
||*`<`*||Open a bracketed section and switch control to player 1.||
||*`/`*||Switch to the next player in a bracketed section.||
||*`>`*||Close a bracketed section.||
||*`$n`*||Save the current state to slot n.<br>This can save checkpoints in a long sequence of commands.||
||*`&n`*||Load savestate slot n. This is useful to put in the first frame.||
||*`()n`*||Repeat the commands enclosed in the parentheses n times. Loops can be nested.||
||*`# text`*||A comment. The rest of the line after the symbol is ignored by the script.<br>Comments that explain what is supposed to happen are recommended.||
||*`###`*||If any comment has three consecutive # symbols, the macro will loop back to the beginning when it reaches the end and repeat indefinitely,<br>both the savestates and the inputs. Stop playback by pressing the start key again.<br><br>This can be useful for reviewing a sequence and, if the emulator supports lua+user input, for practicing against a scripted attack from the other player.||
||*`!`*||End the macro. Any content after the end is ignored by the script, and can be used as comments.<br>Don't forget to advance at least one frame after the last input and before the end.||

Macros are case insensitive. Commas, whitespaces, tabs and newlines can be used for spacing and legibility, but are ignored by the script. The exception is that some separation is required between multiplier or index numbers (such as after a `W`) and numerical key presses.

Analog inputs are not (yet) supported.

=== Synchronous multi-player control with + - ===

    * Commands are applied only to the selected player.
    * Player 1 is selected by default.
    * The + and - symbols are used to switch between players.
    * Time advancement applies to all players.
    * Nonselected players can give input with their held keys.
    * To modify the input of multiple players on the same frame, switch between them before advancing frames.

=== Asynchronous multi-player control with < / > ===

    * Commands are applied only to the selected player.
    * Player 1 is selected when the brackets are opened.
    * Control is switched to the next player after each /.
    * Time advancement applies only to the selected player.
    * When the brackets are closed, time is advanced to the point of the player with the most frames, wait frames are added to the others to make up the difference, all player inputs are multiplexed, and control returns to player 1.
    * The + - symbols are ignored inside brackets.

=== Savestates ===

Save and load operations are performed one frame before the game inputs at the same position. For example, a state operation placed between the second and third dots is done after the second frame advance, while the game inputs there are done after the third. This behavior allows operations to be scripted on the zeroth frame of the macro, resulting in a movie that effectively starts from savestate.

Each emulator has its own limit on savestate indexes.

----
= Control modules =

The game inputs and the symbols used to activate them depend on game system. !MacroLua selects the symbol-input mapping based on what emulator is running it, and in the case of arcade, based on the game being run. The available sets are written in macro-modules.lua, and more can be added. Ask for help if needed.

The traditional format is `U`,`D`,`L`,`R` for up, down, left and right, and numbers counting up from `1` for the buttons. The non-arcade systems have a single keyset for all games, so the format only needs to be defined once for each console.

However, there are many undefined arcade profiles. !MacroLua tries to autogenerate an arcade module if none is available by observing what keys are present in the game. This should work well with games that use an ordinary joystick and numbered buttons.

----
= Configuration options =

The _macro-options.lua_ file contains the user's settings. This file can be edited with any text editor. To update settings, restart the Lua script.

||||The file, path and key options must be enclosed in quotes.<br>The hotkey options are ignored if the emulator supports Lua hotkeys.||
||`playbackfile`||This is the filename of the script to be played.||
||`path`||This is the path where the script file is found and where recordings will be placed. The path may be either relative to macro.lua or absolute. Use either double forward slashes (`.\\path\\`) or single backslashes (`./path/`).||
||`playkey`||Press to start playing the specified script or to cancel an already playing script.||
||`recordkey`||Press to start recording input to a new script and to finish a recording in progress.||
||`inputstreamkey`||Press to convert the playback file to the expanded one-line-per-frame format. The result will be saved as a text file.<br>This feature can help in analyzing scripts. !MacroLua cannot currently parse files in this format.||
||`pauseafterplay`||Set to `true` to pause after a script finishes playing or `false` to not pause.||
||||After recording player input, the results are written to file. The following three options affect the style of the output:||
||`longwait`||Idle frames are collapsed into `Wn` phrases as a shorthand. This option specifies the minimum number of idle frames to trigger this. Set it to 0 to never use `Wn` phrases.||
||`longpress`||When an input is active for many consecutive frames, it is abbreviated as a `_k` at the beginning and a corresponding `^k` at the end instead of writing `k` every frame. This option specifies the minimum number of held frames to trigger this. Set it to 0 to never use `_k ^k` phrases.||
||`longline`||Each player's input can be broken up into multiple lines. This option specifies the minimum number of characters to trigger a linebreak. Set it to 0 to not break up lines.||
||`showarcadeinput`||If set to `true`, this option runs the included _input-display.lua_  script with FBA-rr or MAME-rr, which shows what inputs are being pressed by the players. It has no effect for other emulators, which have their own built-in display features.||
||`framemame`||Set to `true` only if running a script that was made for frameMAME, so that the parser can ignore the audio commands. Otherwise leave as `false`.||

If using hotkeys, they must be selected from the following list. *Key names are case sensitive.*

`shift, control, alt, capslock, numlock, scrolllock, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22, F23, F24, backspace, tab, enter, pause, escape, space, pageup, pagedown, end, home, insert, delete, left, up, right, down, numpad0, numpad1, numpad2, numpad3, numpad4, numpad5, numpad6, numpad7, numpad8, numpad9, numpad*, numpad+, numpad-, numpad., numpad/, tilde, plus, minus, leftbracket, rightbracket, semicolon, quote, comma, period, slash, backslash`

----
= How to mute the background music in arcade games =

You may want to record videos with the sound effects but without the music. The reliable method to disable music is with a cheat code: The memory addresses that control music are forced to hold values that prevent it from playing.

Find the code that works for your game in the _./FBA examples/mutecodes.txt_ file provided. Copy the code into an .ini file that matches the rom's short name and put it in FBA's cheat folder (e.g. _./support/cheats/sfa3.ini_). You may augment this file with other codes as well. Then run the rom (restart if already running) and find Enable Cheats in the Misc menu. If the .ini is properly formatted, the option is available. Click the music entry and select the disable option from the dropbox.

Most of the available FBA mute codes have been converted to MAME xml format and are found in the official cheat code pack. Place _cheat.zip_ in MAME's folder to make the codes available.

Not all games have known mute codes. You can request more at [http://cheat.retrogames.com/ Pugsy's site].

----
= Lua feature availability in each emulator =

||emulator||version tested||`emu` alias||hotkey while paused||lua+user input||bulletproof savestates||adapt to ROMs||
||[http://code.google.com/p/mame-rr/downloads/list MAME-rr]||`0139-test2`||`mame`||○||○||○||○||
||[http://code.google.com/p/fbarr/downloads/list FBA-rr]||`0.0.5`||`fba`||○||○||○||○||
||[http://code.google.com/p/pcsxrr/downloads/list PCSX-rr]||`0.1.3`||`pcsx`||○||○||×||×||
||[http://code.google.com/p/gens-rerecording/downloads/list Gens-rr]||`11a`||`gens`||○||○||○||×||
||[http://code.google.com/p/snes9x-rr/downloads/list snes9x-rr]||`1.43 v17 r123`<br>`1.51 v6 r113`^1^||`snes9x`||×||○||○||×||
||[http://code.google.com/p/vba-rerecording/downloads/list VBA-rr]||`v22 r203`||`vba`||×||○||×||×||
||[http://www.fceux.com/web/download.html FCEUX]||`2.1.3`||`FCEU`||○||○||○||×||
||[http://code.google.com/p/pcejin/downloads/list PCEjin]||`r128`||×||○||×||○||×||
||[http://desmume.org/ DeSmuMe]||`0.9.6`||||||||||not yet tested||
||[http://code.google.com/p/mednafen-rr/ mednafen-rr]||`1.1`||||||||||use [TranScripterDocumentation TranScripter]||
||[http://code.google.com/p/yabause-rr/ yabause-rr]||`svn2541`||||||||||use [TranScripterDocumentation TranScripter]||
||[http://code.google.com/p/mupen64-rr/ mupen64-rr]||`v8`||||||||||does not support Lua||

   * `[1]` snes9x 1.51 only accepts Lua input from within a `while true do` loop, so playback won't work.

||`emu` alias||!MacroLua identifies the emulator and control scheme by the name of this table of functions.||
||hotkey while paused||If `input.registerhotkey()` is available, the user can start and stop recording during pause. The fallback is `input.get()`, which has the same function but cannot be done while paused.<br><br>However, it's possible to use `input.get()` while paused in FBA, PCSX and FCEUX, due to a defect in the Lua implementation. In these cases the hotkeys will activate even if the emulator is not in focus.||
||lua+user input||The emulator may take input from both a Lua script and the user simultaneously if `joypad.set()` allows it.||
||bulletproof savestates||The user may load savestates while playing or recording without losing progress if `savestate.registersave()` and `savestate.registerload()` are available.<br><br>This feature has not been well tested.||
||adapt to ROMs||!MacroLua can name recordings and reset the control scheme based on the loaded game if `emu.registerstart()` and a function that returns the name of the game are present.||